# 数据库

# 一、事务

## 概念

事务指得是满足ACID特性得一组操作，可以通过Commit提交一个事务，也可以使用Rollback及进行回滚。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f74144be-857a-40cd-8ec7-87626ef4e20b.png)

## ACID

## 1.原子性（Atomicity）

事务被视为为不可分割得最小单元，事务得所有操作要么全部执行要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志来实现，回滚日志记录着事务所执行得修改操作，在回滚时反向执行这些修改操作即可。

## 2.一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

## 3.隔离性(lsolation)

**一个事务所做的修改在最终提交以前，对其他事务是不可见的。**

## 4.持久性(Durablilty)

一旦事务提交，则其所作的修改会永久保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

使用重做日志来保持持久性。



事务的ACID，这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才正确。
- 在无并发的情况下，事务串级执行，隔离性一定能够保证。此时只需要满足原子性，就一定可以满足一致性。
- 在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能够应对数据库奔溃情况。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/417bc315-4409-48c6-83e0-59e8d405429e.jpg)

## AUTOCOMMIT

**MySql默认采用自动提交模式**，也就是所，如果不显示使用START TRANSACTION语句来开始一个事务，那么每个查询都被当作一个事务自动提交。



# 二、并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。



### 丢失修改

T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。

![丢失修改](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/75184b58-c627-4edc-8dcf-605762ebb733.png)

T1会发出感叹：我明明将var修改成了50，怎么成了100

## 读脏数据

T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af0e94d9-502d-4531-938f-d46dd29de52d.png)

T1我明明已经撤销了，T2怎么还读到我原先修改的数据。



## 不可重复读

T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![不可重复读](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66ae164c-ad47-4905-895e-51fe38ce797a.png)

T2我两次读的数据值怎么不一样啊？？

## 幻读

T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png)

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。**数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方法处理并发一致性问题。**



# 三、封锁

## 封锁粒度

MySQL中提供了两种封锁粒度：**行级锁以及表锁**。

**并发程度方面考虑**

应该尽量只锁定需要修改的那部分数据，而不是所有资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程序越高。

**加锁开销资源考虑**

但是加锁需要消耗资源，锁的各种操作(包括获取锁，释放锁，以及检查锁的状态，都会增加系统的开销）因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在**锁开销和并发程度之间做一个权衡。**



## 封锁类型

### 1.读写锁

- 排他锁，简写为X锁，又称写锁
- 共享锁，简写为s锁，又称为读锁

以下两个规定：

- 一一个事务对数据对象A加X锁，就可以对A进行读取和更新，加锁期间其他事务不能对A加任何锁。
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其它事务能对A加S锁，但是不能加X锁。

锁的兼容关系

| -     | X    | S    |
| ----- | ---- | ---- |
| **X** | ×    | ×    |
| **S** | ×    | √    |



### 2.意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

存在行级锁和表级锁地情况下，事务T想要对表A加X锁,就需要先检测是否有其他事务对表A或者表中的任意一行加了锁，那么就需要对表的每一行都进行检测一次，这是非常耗时的。

意向锁在原来的X/S锁之上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要在表中的某个数据行加上X锁或S锁。有一下两个规定：

- 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁；
- 一个事务在获得某个数据的对象的X锁之前，必须先获得表的IX锁。

通过引入意向锁，事务T想要对表A加X锁，只需要检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了就表示有其他事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。

各种锁的兼容关系如下：

| -      | X    | IX   | S    | IS   |
| ------ | ---- | ---- | ---- | ---- |
| **X**  | ×    | ×    | ×    | ×    |
| **IX** | ×    | √    | ×    | √    |
| **S**  | ×    | ×    | √    | √    |
| **IS** | ×    | √    | √    | √    |

解释：

- 任意IS/IX锁之间都是兼容的，因为他们只是表示想要对表加锁，而不是真正加锁；
- S锁只与S锁和IS锁兼容，也说事务T想要对数据行加S锁，其他事务可以获得对表或者表中的行的S锁。



## 封锁协议

### 1.三级封锁协议

#### 一级封锁协议

==事务T要修改数据A时必须要加X锁，直到T结束才能释放锁。==

可以**解决丢失修改问题**，因为不能同时有两个事务对同一数据进行修改，那么事务的修改就不会被覆盖。



| T1          | T2          |
| ----------- | ----------- |
| lock-x(A)   |             |
| read A=20   |             |
|             | lock-x(A)   |
|             | wait        |
| write A=19  | .           |
| commit      | .           |
| unlock-x(A) | .           |
|             | obtain      |
|             | read A=19   |
|             | write A=21  |
|             | commit      |
|             | unlock-x(A) |

#### 二级封锁协议

==在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。==

可以**解决读脏数据问题**，因为如果一个事务在对数据A进行修改，根**据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入数据。**

| T1          | T2          |
| ----------- | ----------- |
| lock-x(A)   |             |
| read A=20   |             |
| write A=19  |             |
|             | lock-s(A)   |
|             | wait        |
| rollback    | .           |
| A=20        | .           |
| unlock-x(A) | .           |
|             | obtain      |
|             | read A=20   |
|             | unlock-s(A) |
|             | commit      |



#### 三级封锁协议

==在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。==

可以**解决不可重复读的问题**，**因为读A时，其他事务不能对A加X锁，从而避免了在读的期间数据发生改变。**

| T1          | T2         |
| ----------- | ---------- |
| lock-s(A)   |            |
| read A=20   |            |
|             | lock-x(A)  |
|             | wait       |
| read A=20   | .          |
| commit      | .          |
| unlock-s(A) | .          |
|             | obtain     |
|             | read A=20  |
|             | write A=19 |
|             | commit     |

### 2.两段锁协议

==**加锁和解锁分为两个阶段进行。**==

可串行化调度是指，**通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。**

**事务遵循两段锁协议是保证可串行化调度的充分条件**。例如以下操作满足两段锁协议，它是可串行化调度。

```sql
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但是不是必要条件，例如如下操作不满足两段锁协议，但是它还是可串行化调度。

```sql
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```



## MySQL隐式与显示锁定

MySQL的默认引擎InnoDB存储引擎采用两段锁协议，会根据隔离界别在需要的时候自动加锁，并且有的锁是在同一时刻被释放的，这被称为隐式锁定。

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```



# 四、隔离级别

## 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其他事务也是可见的。



## 提交读(READ COMMITTED)

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。



## 可重复读(REPEATABLE READ)

保证在同一个事务中多次读取同样数据的结果是一样的。



## 可串行化读（SERIALIAZBLE）

强制事务串行执行。

需要加锁实现，其他隔离级别通常不需要加锁

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| -------- | ---- | ---------- | ------ |
| 未提交读 | √    | √          | √      |
| 提交读   | ×    | √          | √      |
| 可重复读 | ×    | ×          | √      |
| 可串行化 | ×    | ×          | ×      |



# 五、多个版本并发控制

**多个版本并发控制**(Multi-Version Concurrentcy Control , MVCC）是MySQL的InnoDB存储引擎实现隔离界别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。可串行化隔离界别需要对所有读取的行都加锁，单纯MVCC无法实现。

## 版本号

- 系统版本号：是一个递增的数组，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。

## 隐藏的列

MVCC在每行记录后面都保存着两个隐藏的列，用来存储两个版本号。

- 创建版本号：指示创建一个数据行的快照时的系统版本号；
- 删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

## Undo日志

MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行（Record）的所有快照链接起来。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e41405a8-7c05-4f70-8092-e961e28d3112.jpg)

## 实现过程

以下实现过程针对可重复读隔离级别

当开始一个事务时，该事务的版本号肯定大于当前所有数据快照的创建版本。理解这一点很关键。数据快照创建版本号是创建数据行快照的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之间的系统版本号都大，也就是比所有数据行快照的创建版本号都大。

### 1.select

多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其他事务的读取结果一致。

把没有对一个数据行做修改的事务称之为T,T所要读取的数据行快照的创建版本号必须小于等于T的版本号，**因为如果大于T的版本号，那么表示该数据行快照是其他事务的最新修改，因此不能去读取它**。除此之外，T所要读取的数据行快照的删除版本必须是未定义或者大于T的版本号，如果小于等于T的版本号，那么表示该数行快照已经被删除了，不应该去读取他。

### 2.insert

将当前系统版本号作为数据行快照的创建版本号。

### 3.delete

将当前系统版本号作为数据行快照的删除版本号。

### 4.update

将当前系统版本号作为更新的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号，可以理解为先执行delete后执行insert.



## 快照读与当前读

### 1.快照读

使用MVCC读取的是快照中的数据，这样可以减少加锁带来的开销。

```sql
select * from table ...;
```

### 2.当前读

读取的是最新的数据，需要加锁。以下第一个语句需要加S锁，其他需要加X锁。

```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```



# 六、Next-Key Locks

Next-Key Lock是MySQL的InnoDB存储引擎的一种锁实现。

MVCC不能解决幻影读的问题，Next-Key Locks就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别，使用MVC + Next-Key Locks可以解决幻读问题。



## Rcord Locks

**锁定一个记录上的索引，而不是记录本身。**

如果表没有设置索引，**InnoDB会自动在主键上隐藏的聚簇索引**，因此Record Locks依然可以使用。

## Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当前一个事务执行以下语句，其他事务就不能在t.c中插入15.

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

它是Record Locks和Gap Locks的结合，**不仅仅锁定一个记录上的索引，也锁定索引之间的间隙**。例如一个索引包含以下值：10，11，13，and 20,那么就需要锁定以下区间。

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```



# 七、关系数据库设计理论

## 函数依赖

记A->B表示A函数决定B,也可以说B函数依赖于A.

如果{A1, A2 , …., An}是关系的一个或者多个属性的集合，该集合函数决定了关系的其他所有属性并且是最小的，那么该集合就称为键码。

对于 A->B ,如果能找到A的真子集A`，使得A‘->B,那么A->B就是部分函数依赖，否则即使完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖

## 异常

以下的学生课程关系的函数依赖为{Sno,Cname} -> {Sname,Sdept,Mname,Grade},键码为{Sno,Cname}。也就是说，确定学生和课程之后，就能确定其他信息。

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 |        |       |

不符合范式的关系，会产生很对异常，主要有以下四种异常：

- 冗余数据：例如`学生-2`出现了两次
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

## 范式

范式理论为了解决以上提到的4种异常。

高级别范式的依赖于低级别的范式，1NF是最低级别的范式。

### 1.第一范式（1NF）

属性不可分

### 2.第二范式（2NF）

每个非属性完全函数依赖于键码。

可通过分解来满足。

### 分解前

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

以上学生课程关系种，{Sno,Cname}为键码，有如下函数依赖：

- Sno -> Sname,Sdept
- Sdept -> Mname
- Sno, Cname->Grade

Grade完全函数依赖于键码，它没有任何冗余，每个学生的每门课都有特定的成绩。

Sname,Sdept和Mname都部分依赖于键码，当一个学生选修了夺门课时，这些数据就会出现多次，造成大量冗余数据。

### 分解后

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| ---- | ------ | ------ | ------ |
| 1    | 学生-1 | 学院-1 | 院长-1 |
| 2    | 学生-2 | 学院-2 | 院长-2 |
| 3    | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname

关系-2

| Sno  | Cname  | Grade |
| ---- | ------ | ----- |
| 1    | 课程-1 | 90    |
| 2    | 课程-2 | 80    |
| 2    | 课程-1 | 100   |
| 3    | 课程-2 | 95    |

有以下函数依赖：

- Sno, Cname -> Grade

### 第三范式(3NF)

非主属性不传递函数依赖于键码

上面的关系-1中存在以下依赖函数依赖：

- sno -> Sdept ->Mname

可以进行以下分解：

关系-11

| Sno  | Sname  | Sdept  |
| ---- | ------ | ------ |
| 1    | 学生-1 | 学院-1 |
| 2    | 学生-2 | 学院-2 |
| 3    | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| ------ | ------ |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |



**第一范式（1NF）：**强调的是列的原子性，即列不能够再分成其他几列。 

**第二范式（2NF）：**首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。

**第三范式（3NF）：**首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。

# 八、ER图

Entity-Relationship 有三个组成部分：**实体，属性，联系**

用来进行关系型数据库系统的概念设计。

## 实体的三种联系

包含一对一，一对多，多对多三种。

- 如果A到B时一对多关系，那么画个带箭头的线段指向B;
- 如果是一对一，画两个带箭头的线段；
- 如果是多对多，画两个不带箭头的线段。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png)

## 表示出现多次的关系

一个实体的联系出现几次，就要用几条线连接。

下图表示一个课程的先修关系，先修关系出现两个Course实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png)

## 联系的多向性

虽然老师可以开设多门课。并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，就构成了一个三元联系。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png)

## 表示子类

用一个三角形和两条线来链接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png)