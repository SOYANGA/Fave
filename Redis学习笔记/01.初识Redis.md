# 初识Redis

## Redis的铺垫

MySQL的数据都是存储在磁盘中的，虽然在数据库层也做了对应的缓存，但是此缓存只是针对不变动的数据（读数据做缓存，写数据清理缓存）。即这种数据库的缓存仅仅针对的查询的内容而且粒度比较小。一般只有表中数据库未发生变动的时候数据库对应的Cache才能发挥作用。

无法减少业务系统对数据库产生的增删改查的IO压力，因此缓存数据库应运而生。该技术实现了对热点数据的高速缓存，提高应用的响应速度，极大的缓解后端MySQL数据库的压力。

![1566116158126](C:\Users\32183\AppData\Roaming\Typora\typora-user-images\1566116158126.png)



## 面对缓存db穿透如何解决

- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层数据系统的查询压力。（博隆过滤器判断一个数据不存在则这个数据真的是不存在，反之判断一个数据存在则这个数据不一定存在）**可以一定程度上进行拦截不存在的请求，但是需要支持扩容机制，以及扩容后的多个位图，都将会被查询，降低了查询效率。**
- **更为简单的方法，如果一个查询返回的数据为空，我们任然将这个空结果去缓存，但是它的过期时间会很短，最长不过5分钟。**



## 如何保证缓存与数据库双写时的一致性？

如果要使用缓存，就可能涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题。那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的，缓存可以稍微跟数据库偶尔不一致的情况，最好不要做这个缓存与数据库双写的一致性操作。

**解决方案**

将读请求和写请求串行化，串到一个内存队列中去，这个可以保证一定不会出现不一致的情况。

**串行化后，就会导致系统的吞吐量大幅度降低，**用比正常情况下多几倍的机器去支撑一个请求。



## 熔断技术

当MySQL数据库挂掉之后，Redis层还可以工作此时的请求就直接经过Redis返回给客户端。



## 缓存中间件——Memcache 和 Redis的区别



### Memcache:代码层次类似Hash

- 支持简单的数据类
- 不支持数据持久化存储
- 不支持主从同步
- 不支持分片



### Redis

- **数据类型丰富**
- **支持数据磁盘持久化存储**
- 支持主从同步
- 支持分片



### 为什么Redis为什么这么快

官方提供的是：10万的并发+的qps（每秒内查询次数）

- 完全基于内存的，绝大部分请求是纯粹的内存操作，执行效率高。
- 单进程，单线程模型的K-V数据库，由C语言编写。读写的时候不会受硬盘IO速度的限制。
- 数据简单，对数据操作也简单
- Redis不使用表，不会要求用户对存储的不同数据强制性的进行关联，因此性能高出关系型数据库不知一个量级。
- 其存储结构就是k-v键值对，其查找，操纵的时间复杂度都是O(1)的。
- 采用单线程，单线程也能处理高并发请求，想使用多核也可以启动多实例。
- **正因为采用单线程处理，所以对于客户端所有请求都采用串行处理，因此多个客户端对一个键进行写操作时，就不会产生并发问题，避免了频繁的上下文切换，锁竞争使得Redis执行起来效率更高。（配合IO多路复用即可实现超高效率）**
- **多核提高性能问题Redis已经做了相关的验证，Redis的qps相当高，并且在qps峰值的时候，Redis并不会跑满CPU。只是由于网络等原因导致并发量不能进一步上升，因此cpu并不是制约Redis的性能瓶颈。**

> 这里的单线程，只是说在处理网络请求中，我们使用单线程来处理。Redis Server并不是只有一个线程在处理。例如：Redis在持久化的时使用子进程或者子线程对Redis做持久化处理。

- 使用多路I/O复用模型，非阻塞IO（NIO）

  Redis是在单线程执行由于读写操作会等待用户的输入输出时会出现阻塞，所以IO操作往往不能直接返回，进而导致整个进程无法对其他客户端提供服务。而IO对路复用是针对这个问题而出现的。



## 多路I/O复用模型

### 文件描述符

**FD：**File Descriptor, 文件描述符*（用一个整数来表示）*

​	**操作系统中，一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。**



### 传统的IO阻塞模型

![1566119511319](C:\Users\32183\AppData\Roaming\Typora\typora-user-images\1566119511319.png)

会影响其他FD对应的服务，所以在需要处理多个任务处理任务的时候往往不会使用阻塞IO模型。



### IO多路复用模型



**Select**系统调用

![1566119661055](C:\Users\32183\AppData\Roaming\Typora\typora-user-images\1566119661055.png)

> Select 可以同时监控多个文件描述符的可读可写情况，当某个文件描述符可读可写时，Select就会返回这个可读可写的文件描述的个数。
>
> Select是负责监听文件是否可读或者可写的将监听的任务交给Selecter后我们的程序就不会被阻塞了，可以执行其他任务去了。

### Redis采用的I/O多路复用函数：epoll/kqueue/evport/select



- 因地制宜

  - 因为Redis需要在多个平台上运行，为了最大化的提高执行效率和性能，会根据编译平台的不同。选择不同的I/O多路复用函数作为子模块。提供给上层统一的接口

  - redis的多路复用， 提供了select, epoll, evport, kqueue几种选择，在编译的时候来选择一种。

    select是POSIX提供的， 一般的操作系统都有支撑
    epoll 是LINUX系统内核提供支持的；
    evport是Solaris系统内核提供支持的；
    kqueue是Mac 系统提供支持的；

- 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现

- 一时间复杂度为O(n)的select作为保底

  - 因为select是POSIX提供的， 一般的操作系统都有支撑，会扫描监听的全部文件描述符，所以时间复杂度较大为O(n)

- 基于react设计模式监听I/O事件（文件事件处理器）

  - 文件事件处理器采用I/O多路复用模块监听多个fd,accept,read,close事件产生时，文件事件处理器就会回调fd绑定的事件处理器。虽然文件事件处理器是单线程下的，但是采用I/O多路复用，实现了对多个fd读写的监控，提高了网络通信模型的性能，同时可以保证整个Redis服务的实现简单。