# 排序章节学习总规划

| 章节 | 排序算法         | 时间复杂度 | 是否基于比较 |
| ---- | ---------------- | ---------- | ------------ |
| 11   | 冒泡，插入，选择 | O(n^2)     | :heavy_check_mark: |
| 12   | 快排，归并       | O(nlogn)   | :heavy_check_mark: |
| 13   | 桶，计数，基数   | O(n)       | :heavy_multiplication_x: |

# 带着问题​ :grey_question:

插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？



# [11] 排序(上) -数据结构算法之美 :happy:



## 分析排序算法的三个方面 :thumbsup:



### 排序算法的执行效率-1:one:

#### 1.最好情况，最坏情况，平均时间复杂度

我们分析排序算法的时间复杂度的同时也要分析==**最好，最坏时间复杂度对应的要排序的原始数据**==  是什么样的。**（数据已经有序，数据接近有序，数据完全无序，数据逆序）**



#### 2.时间复杂度的系数，常数，低阶

时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势往往会忽略系数，常数，低阶项。但是实际开发中可能排序数据规模上不一定会规模很大。所以对于同一阶次时间复杂度算法性能对比的时候，我们就要把系数，常数，低阶考虑进来。



#### 3.比较次数 和 交换(或移动)次数

基于比较的排序算法，会涉及两种操作，一种是元素比较大小，另一种是元素交换或者移动。所以，我们分析排序算法执行效率的时候，应该把比较次数和交换（或者移动）次数也考虑进去。



### 排序算法的内存消耗-2:two:

算法的内存消耗：可以通过空间复杂度来衡量。

针对排序算法的空间复杂度，我们还引入一个新概念，**原地排序（Sorted in place）**:特指空间复杂度是O(1)的排序算法。

**冒泡，插排，选择排序都是原地排序**。



### 排序算法的稳定性-3:three:

==**稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。**==

**例1： ** 

一组数据 2，9，3，4，8，3按照升序排列，则排完是2，3，3，4，8，9。排序后两个3的先后次序不变。

**例2：** 

交易订单中"订单"排序。订单中有两个属性，一个下单时间，另一个是订单金额。如果说我们现在有10万条订单数据·。我们希望

- 按照订单金额从小到大对订单数据进行排序

- 对于相同的订单，我们希望按照下单时间从早到晚有序

对于这样一个排序需求我们应该如何去做呢？

先对整个**订单数据按照下单时间进行升序排列(可以不是使用稳定排序)**，然后再整体使用**稳定排序算法，按订单金额重新排序**即可。

**分析：** 稳定排序算法可以保持金额相同的对象，在排序之后前后顺序不变。第一次排序之后，所有订单按照下单时间从早到晚就有序了。**第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。** 



## 冒泡排序(Bubble Sort) :right_anger_bubble:

冒泡排序只会操作*相邻的两个数据*。每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系的要求。如果不满足就让他俩互换。**一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作** 

**优化：**当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后面的冒泡操作了。

**优化前：** 

![冒泡排序算法图](D:\婕\数据结构与算法之美\picture\冒泡排序算法图.jpg)

**优化后：** 

![冒泡排序算法图优化](D:\婕\数据结构与算法之美\picture\冒泡排序算法图优化.jpg)

代码如下：

```java
//冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[]a,int n){
    if(n<=1){ //如果只有元素，不需要排序
        return;
    }
    for(int i = 0;i < n; ++i){
        //提前退出冒泡循环的标志位
        boolean flag = false;
        for(int j = 0 ;j < n-i-1; ++j){
            if(a[j] > a[j+1]){
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                flag = true; //表示有数据交换
            }
        }
        if(!flag){
            break;//没有数据交换，提前退出
        }
    }
}
```



### 冒泡排序算法分析

- **冒泡排序是原地排序算法**

  冒泡排序冒泡过程**只涉及相邻的数据交换操作**，是原地排序算法，只需要常量级临时空间。空间复杂度是O(1)，是一个原地排序算法。

- **冒泡排序是稳定排序算法**

  交换时值改变了两个元素的前后顺序。为了保证冒泡排序算法的稳定性*，我们在比较时规定当有相邻元素大小相同时，我们不做交换*，**相同大小的数据在排序前后不会改变顺序**，所以冒泡排序是稳定的排序算法。

- 冒泡排序时间复杂度。最好，最坏，平均

  | 时间复杂度             | 对应原始数据                     |
  | ---------------------- | -------------------------------- |
  | 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组 |
  | 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                      |
  | 平均时间复杂度：O(n^2) | 数据的有序度的平均水平           |

  平均时间复杂度运用概率论的方法难以计算，引入一个**有序度**的概念

​	**有序度：** 是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表式就是

> ```java
> 有序元素对：a[i] <= a[j],如果i<j
> ```

​	**满序度：**完全有序的序列，的有序对数

> ```java
> 满序度:排序完成后终态有序度为   n*(n-1)/2
> ```

​	**逆序度：数组中无序逆序关系得元素对的个数。** 

> ```java
> 逆序度对：a[i] > a[j],如果i<j
> ```

​	                                                **逆序度 = 满序度-有序度** 

​	拿之前的那个例子来说，数组初始状态是4，5，6，3，2，1。其中有序对有(4,5)(4,6)(5,6)

​	所以有序度是3。n=6,所以排序完成之后终态满有序度为n*(n-1)/2=15。

​	![有序度规律](D:\婕\数据结构与算法之美\picture\有序度规律.jpg)

冒泡排序包含的**两个原子操作，比较**和**交换**。每冒泡（交换）一次，有序度就加1，不管算法怎么改进交换次数总是确定的。即为**逆序度，也就是n*(n-1)/2-初始有序度。**在这个例子中15-3 = 12则要进行12次交换操作。

对于包含n个数据的冒泡排序平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n\*(n-1)/4 次交换操作，**比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。** 



## 插入排序(Insertion Sort):diamond_shape_with_a_dot_inside:

将数组中的数据分为两个区间，已**排序区间和未排序区间**。**初始已排序区间只有一个元素，就是数组的第一个元素。**==插入算法的核心思想是**取未排序区间中的元素。在已排序区间中找到合适的插入位置将其插入，并确保已排序区间数据一直有序**。== 重复这个过程，**直到未排序区间中元素为空，则排序就完成了。** 

插入排序也包含**两种操作，元素的比较，元素的移动**。当我们需要将一个数据a插入到已排序区间时，需要拿**a与已排序区间的元素依次比较大小**，**找到合适的插入位置**。找到合适的插入位置后，我们还需要将**插入点之后的元素统一往后移动一位，腾出空间给元素插入**。



对于不同的查找插入点方法（从头到尾，从尾到头）,元素的**比较次数是有区别的** 。但是对于一个给定的初始序列，**移动操作的次数总是固定的，就等于逆序度**。

> 初始有序度为5，满序度为n*(n-1)/2=15,逆序度为10，插入排序一定数据总和也等于10 =3+3+4

![插排排序图](D:\婕\数据结构与算法之美\picture\插排算法图.jpg)

**代码入下：** 

```java
//插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n){
    if(n <=1){
        return;
    }
    for(int i = 1; i < n; ++i){
        int value = a[i]; //记录要插入的元素
        int j = i-1; //已排序区
        //查找插入位置
        for(; j >= 0; --j){
            if(a[j] > value){
                a[j+1] = a[j];//数据移动
            }else{
                break;
            }
        }
        a[j+1] = value; //将要插入的位置插入合适的位置，有序区数量+1，无序区数量-1
    }
}
```



### 插入排序算法分析

- **插入排序是原地排序**

  不需要额外的空间，空间复杂度O(1)

- **插入排序是稳定排序** 

  在插入排序中，对于值相同的元素，我们规定**将后面的出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。**

- **插入排序的时间复杂度**

  | 时间复杂度             | 对应原始数据                          |
  | ---------------------- | ------------------------------------- |
  | 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组      |
  | 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                           |
  | 平均时间复杂度：O(n^2) | 在数组中插入一个数据O(n)，循环执行n次 |

数组中插入一个元素时间复杂度O(n):（1+2+3+4+...n)/n = O(n)



## 选择排序(Selection Sort):aquarius:

选择排序与插排类似，也分为**排序区和未排序区**。但是选择排序每次会==**从未排序区间中找到最小的元素，将其放到已经排好序的末尾。**== 

![选择排序算法图](D:\婕\数据结构与算法之美\picture\选择排序算法图.jpg)

**代码：**

```java
public void SelectionSort(int[] a,int n){
    if(n<=1){
        return;
    }
    fot(int i = 0; i < n; i++){
        int minindex = i;
        for(int j = i; j < n; j++){
            if(a[j]<a[minindex]){
                 minindex = j;
            }
        }
        if(min != i){
            int temp = a[i];
            a[i] = a[minindex];
            a[minindex] = temp;
        }
    }
}
```



### 选择排序算法分析

- **选择排序是原地排序**

  不需要额外的空间，空间复杂度O(1)

- **选择排序==不== 是一种稳定排序**

  从图中可以看出，排序过程中将最小元素和最后一位交换位置，则会导致最后一位元素可能会移动到和它值相同的元素的前面，波坏了稳定性

- **选择排序时间复杂度**

  | 时间复杂度             | 对应原始数据                                   |
  | ---------------------- | ---------------------------------------------- |
  | 最好时间复杂度：O(n^2) | 无论原始数据如何，时间复杂度都是O(n^2)         |
  | 最坏时间复杂度：O(n^2) | 原因是：查找无序区间的最小值总得遍历一遍无序区 |
  | 平均时间复杂度：O(n^2) |                                                |

逊色冒泡，插入排序。



# 解答开始的问题:key:

我们来看开篇的问题：插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？

**我们分析了冒泡排序和插入排序，不管如何优化，元素交换次数是一个都定值，即原始数据的无序度**

但是从代码实现上来看，==**冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序有要3个赋值操作，而插入排序只需要1个赋值操作。**==

```java
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}

```



**我们把执行一个赋值语句的时间粗略记为单位时间（unit_time）,然后分别用冒泡排序和插入排序对同一个逆序度为k的数组进行排序，需要进行k次交换操作。冒泡排序，每次需要进行3条赋值语句，所以交换操作总耗时就是==3*k== 单位时间，而插入排序中数据移动操作只需要==k== 个单位时间。**

虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n^2),但是我们希望把性能优化到极致，所以我们首选插入排序。插入排序还可以进行进一步优化。比如==**希尔排序**== 



# 小结:package:

![小结](D:\婕\数据结构与算法之美\picture\小结.jpg)