# 复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度



应用场景主键增加：

## 最好时间复杂度：

> 在最理想的情况下，执行这段代码的时间复杂度。

## 最坏时间复杂度：

> 在最糟糕的情况下，执行这段代码的时间复杂度

## 平均时间复杂度：

> 使用概率论知识计算每一个情况出现的概率这个值就是概率论中的加权平均值，也称作期望值，所以平均时间复杂度的全称应该是  **加权平均时间复杂度**或者 **期望时间复杂度。**

## 均摊时间复杂度：平均时间复杂度的特殊情况

均摊时间复杂度就是一种特殊的平均时间复杂度

> 通过摊还分析：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度有都很低，只有个别情况下时间复杂度比较高而且这个操作之间存在前后连贯的时序问题，**这个时候，我们就可以将这组操作放在一块分析，看能否能将较高时间复杂度的那次操作的耗时，平摊到其他时间复杂度比较低的操作上。**而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间时间复杂度就等于最好时间复杂度。



```c
// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加 1
   array[i] = element;
   ++i;
}

```

**分析：**

> 最好时间复杂度分析：O(1)：没有扩容存储数据的的时候
>
> 最坏时间复杂度分析：O(n)：扩容存储数据的时候
>
> 平均时间复杂度分析：归为一类分析其中一种即可

> 均摊时间复杂度分析：O(1)(为扩容)、 O(n)（扩容时） 均摊后O(1)



