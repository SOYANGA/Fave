# [15]二分查找(上)：如何用最省内存的方式实现快速查找功能

## 二分查找(Binary Search) :open_book:

Binary Search 算法，也称折半查找。二分查找的思想很简单-类似与小时候玩的猜数字游戏。

一个人先确定一个数组，另一个随便猜一个数字(中间数)。确定数字的那个人只需要说大了还是小了就行。每说一次就能让可能存在这个数的区间减小一半，知道区间减小到只有一个数字即猜对了这个数。(最坏情况)

![二分查找猜数字游戏](D:\婕\数据结构与算法之美\picture\二分查找猜数字游戏.png)

### 小总结

**二分查找针对的是一个==有序的数据结合==，查找思想有点类似分治思想，每次都通过跟区间的==中间元素==对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0**

二分查找的时间复杂度：O(logn)

> 被查找期间的大小变化
>
> n ，n/2 , n/4 , n/8 , n/2^k...

可以看出，这是一个等比数列。其中n/2^k=1时，k的值就是总共缩小的次数，而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就时O(k)。又因为n/2^k=1,我们可以求出k=log2n，所以时间复杂度就是O(logn)。

O(logn) 的时间复杂度比一定比O(1)时间复杂度的算法执行效率高。大O标记法表示时间复杂度得到时候，会忽略掉低阶，常数，系数。对于常量级的时间复杂度算法来说。O(1)可能表示的是一个非常大的常量值,比如O(1000),O(10000).所以常量级时间复杂度算法有时候可能还没有O(logn)的算法执行效率高。



## 简单版本二分查找的递归与非递归实现

最简单的情况就是有序数组中不存在重复元素。

### 非递归版

```java
public int bsearch(int[] a,int n,int value){
    int low = 0;
    int high = n-1;
    
    while(low <= high){
		int mid = low + ((high-low) >> 1);
		if(a[mid] == vaule){
            return mid;
		}else if(a[mid]<value){
            low= mid - 1;
		}else{
            high = mid - 1;
		}
	}
	return -1;
}
```

#### 注意：

##### 循环的条件

```java
low<=high
```

##### mid的取值

```
如果使用mid = (low+high)/2，可能会导致数据的溢出。改进方法有三种
1.mid = low +(high-low)/2;
2.mid = low+((high-low)>>1);
3.mid = (low&high)+((low^high)>>1);
```

##### low和high值的更新

low=mid+1,high=mid-1。注意这里的+1和-1.如果直接写成low=mid或者high=mid，就可能造成死循环，因为当low=3,high=3时但是a[3]不能与value,本应该就跳出循环，但是如果low和high的更新值错误导致死循环。

### 递归版

```java
//二分查找递归实现
public int bsearch(int[]a,int n,int val){
    return brearchInternally(a,0,n-1,val);
}

private int brearchInternally(int[]a,int low,int high,int value){
    if(low>high){
        return -1;
    }
    int mid = low+((high-low)>>1);
    if(a[mid]==value){
        reutrn value;
    }else if(a[mid]<vlaue){
    	return brearchInternally(a,mid+1,high,value);
    }else{
        return brearchInternally(a,low,mid-1,value);
    }
}
```

## 二分查找的应用场景的局限性



| 时间复杂度 | 使用特定数据结构存储数据                                     | 数据必须达到的特殊要求                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| O(logn)    | 二分查找依赖舒顺序表(数组)，按下标随机访问数据时间复杂度O(1) | 二分查找针对的有序数据，且不能频繁的删除，插入。一次排序，多次二分查找 |

### 特定的数据结构顺序表-数组

二分查找需要按照下标随机访问。数组按照下标随机访问数据时间复杂度是O(1),而链表随机访问时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂度就会变得很高。



### 针对的数据必须是有序的

要想使用二分查找时，数据必须是有序的。如果数据没有序，我们需要先排序。排序最低的时间复杂度是O(nlogn)。如果我们针对的是一个静态的数据，没有频繁的插入，删除，我们可以进行一次排序，多次二分查找。这样排序成本被均摊了，二分查找的边际成本就会比较低。

但是针对动态的数据，一直有数据的频繁的插入和删除操作，要想使用二分查找，要么每次插入，删除操作后保证数据仍有序，要么在每次二分查找前必须进行排序。这种动态数据集合，无论那种方法，维护有序的成本都很高。

二分查找只能应用在插入和删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找不再适用。我们将适用二叉树。



### 数据量太小不适合二分查找

如果要处理的是数据量很小的数据，没有必要适用二分插找，直接使用顺序遍历就可以了。只有数据量比较大时，二分查找的优势才会比较明显。



但是有一个特例：

比如数据之间的比较操作比较耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间对比就会非常耗时。我们需要尽可能的减少比较次数，而比较次数的减少会大大提高性能，此时使用二分查找效果更好。



### 数据量太大也不适合二分查找



原因二分查找依赖的数据结构，数组为了支持随机访问的特性，要求内存空间连续，对没存的要求比较严格。我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。

"连续"的意思就是，即便有2GB的内存空间剩余但是，如果剩余的2GB的内存空间时不连续的，没有一块连续的1GB内存空间，那样照样无法申请一个1GB大小的数组。因为基于数组数据结构的原因，所以太大的数据用数组存储就比较吃力了，所以就不能使用二分查找了。



## 总结:

二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找区间缩小为一半，直到找到要查找的元素，或者区间被缩小为0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易错的地方：

- 循环退出条件
- mid取值（求了两个数的平均值）
- low和high的更新

二分查找虽然性能优秀，但是应用场景也比较有限。底层必须依赖数组，并且还要求数据时有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据的插入，删除操作。







