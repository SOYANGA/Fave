# [13]排序(下)-线性排序:strawberry:



| 非基于比较的 线性排序 | 时间复杂度 | 适用场合                                                     |
| --------------------- | ---------- | ------------------------------------------------------------ |
| 桶排序                | O(n)       | **数据量大，数据存储在磁盘上，内存有限（数据范围不大）**     |
| 计数排序              | O(n)       | **计数排序只能用在数据范围不大的场景中**                     |
| 基数排序              | O(n)       | **数据可以划分高低位，且每一位之间后递进关系，每一位范围不能大，因为每一位的稳定排序依赖桶排或者计数排序** |



桶排序，计数排序，基数排序都是线程排序。之所以可以做到线程的时间复杂度，主要原因是，这三个算法是基于**非比较** 的排序算法，都不设计元素之间的比较操作。

**这几种排序对要排序的数据要求很苛刻，我们重点要学习的是这三种排序的适用场景。** 

# 思考题:thinking:

如何根据年龄给100万用户排序？O(n)



# 桶排序(Bucket Sort):package:

## **核心思想:collision:**

将要排序的数据分到几个有序桶中，每个桶里的数据再单独进行排序**。桶内排完序后，再把**每个桶里的数据按照顺序依次取出**，组成的序列就是有序的了。

- 将要排序数据分到**有序桶中** 
- **每个桶中数据进行排序**
- 桶内排完序后，再把**每个桶里的数据按照顺序依次取出**。



### **桶排序为什么是O(n)时间复杂度** 

![桶排序示例](D:\婕\数据结构与算法之美\picture\桶排序示例.png)

### **分析：**

排序的数据有n个，我们把他们均匀的划分到m个桶内，每个桶就有k=n/m个元素。每个桶内部使用快排，时间复杂度O(K*logk)。m个桶排序的时间复杂度就是O(m\*klogk),因为k = n/m,所以整个桶排序的时间复杂度就是O(n\*log(n/m))。**当桶的个数接近与数据个数n时，log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度接近O(n)。**



**但是**以上能实现O(n)时间复杂度的**前提是**

**一是：** 

> - **能将数据很容易的划分成n个桶，**
>
> - **桶与桶之间有着天然的大小顺序。**

**这样每个桶内的数据都排完序后，桶与桶之间的数据就不需要再进行排序了。**

**二是：** 

> - **数据再各个桶之间的分布是比较平均的。**

如果数据经过桶的划分之后，有些桶里的数据非常多，有些桶里的数据非常的少，很不平均，那通内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)排序算法了。



## 适应场景:sun_with_face:

**桶排序比较适合用在外部排序中。** ***所谓的外部排序就是数据存储啊在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。*** 



## 借助桶排序来处理问题：10G订单数据按照订单金额进行排序

我们只有几百MB，没办法一次性把10G数据都加载到内存中。这时我们可以利用桶排序的思想来处理这个问题。

1. 我们可以先扫描一遍晚间，看订单金额所处于在金额范围，将订单分到固定个数的桶中

   > 假设我们得到订单金额的范围是**最小是1元到最多是10多万元**，我们根据订单金额将订单分到**100个桶中**去，第一个通我们存储1元~1000之内的定单，第二个桶中存储1001~2000元之内的订单以此类推。

2. 每个桶对应一个文件（文件有序号），并且按照金额范围大小顺序编号命名(00,01,02...,99).

   > 在理想情况下，如果订单金额从1到10万元之间均匀分布，那么订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，我们就可以将100个小文件依次存放到内存中用快排来进行排序，等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个文件中的订单数据，并将其写入一个大文件中，那么这个文件中存储的就是按照金额从小到达的订单数据了



### 问题：订单金额很有可能并不是均匀分布在1~10万元的内

**递归式划分大文件，直到所有文件都可以被读取到内存中进行快排。**

所以10G订单数据是无法均匀地被划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对用的文件就会很大，没法一次性读取到内存中。

此时我们需要针对比较大的文件，继续对其进行划分，比如，订单金额咋子1元到1000元之间的比较多，我们就将这个区间继续划分你为10个区间，1元到100元，101到200元...

假如谋个区间内订单还是太多了，无法一次性读入到内存中，我们就继续划分，直到所有文件都能读入到内存中进行快排。



# 计数排序(Counting Sort):desktop_computer:



## 适用场景:sunny:

计数排序是桶排的一种特殊情况。***当要排序的n个数据，所处的范围并不大的时候*，比如最大值是k,此时我们就可以把数据划分成k个桶，每个桶内的数据值都是相同的，省略到了桶内排序的时间。** 



## 高考考生50万排名问题：

高考总成绩是900分，最小是0分，这个数据的范围很小，所以我们可以分成901个桶，桶中存储的是对哟个分数的人数。桶内考生的分数相同所以的并不需要再进行排序。我们只需要依次扫描完每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是O(n)。

## 如何实现计数排序？

我们要实现稳定的计数排序不能单从某个数据对应个数进行对数据的分组。因为那样不能保证相等数据排序前后的相对前后位置不变，所以我们需要两个辅助数组。

### 辅助数组C[]的创建

一个辅助数组下标表示的是分数，数组内容是小于等于当前下标（分数）的数据个数。

![计数排序辅助数组C](D:\婕\数据结构与算法之美\picture\计数排序辅助数组C.jpg)



- 排序细节



我们从后到前依次扫描数组A，为什么从后向前是因为保证计数排序的稳定性。比如我们从后扫描遇到3时，我们可以从数组C中取出下标为3的值7，也就时说，到目前为止，包括这个3在内，分数小于等于3的考生有7个，也就是说3时数组R（排好序的数组）的第7个元素（也就是数组R中下标为6的为止）。当3放入到数组R中后，小于等于3的元素就只剩下了6个，所以相应的C[3]中存储的数值要减1，变成6。

依次类推，当我们扫描到第2个分数为3的考生的时候，就会把它放入数组R中的第6个元素的位置（也就是排序数组下标为5的位置）。当我们扫描完整个数组A后，数组R内的数据就是按照分数从小到大的有序排列了。

![计数排序细节](D:\婕\数据结构与算法之美\picture\计数排序细节.jpg)



代码如下：



```java
//计数排序，a是数组，n是数组的大小。假设数组存储的都是非负整数
public void countingSorot(int[] a, int n){
    if(n<=1){
        return;
    }
    
    //查找数组中数据的范围
    int max = a[o];
    for(int i =1; i < n; i++){
        if(max < a[i]){
            max = a[i];
        }
    }
    //1.创建辅助数组C[]
    int[] c = new int[max+1];//申请一个计数数组，下标大小[0,max]
    for(int i = 0; i <= max; i++){
        c[i] = 0;
    }
    
    //计算每个元素的个数，放入C中
    for(int i = 0; i < n; i++){
        c[a[i]]++;     //拆解 c[下标为分数] 分数=a[i]  c[下标]：分数为下标数的个数++
    }
    
    //依次累加  得到辅助数组C[]中存储的是小于等于该数的数据个数
    for(int i = 1; i <= max; i++){
        c[i] = c[i-1]+c[i];
    }
    //2.排序数组的创建，排序之后的结果
    int[] r = new int[n];
    //计算排序的关键步骤！！！
    for(int i = n- 1; i >= 0; i++){
        int index = c[a[i]]-1;  //该分数对应放在排序数组的下标位置
        r[index] = a[i];
        c[a[i]]--;//小于等于该分数的数据个数-1；
    }
    //将结果拷贝给a数组
    for(int i = 0； i < n; i++){
        a[i] = r[i];
    }
}
```



## 计数排序详解



**计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不使用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。** 

关于将数据转化为能使用计数排序的方法如下：

1. 如果是分数就将分数化为整数。*10的倍数
2. 如果是负数就将分数化为整数。+整数



# 基数排序（Radix sort）

假设我们要对10万个手机号码进行排序，希望将这10万个手机号码从小到大进行排序？

## 对10万个手机号码进行排序

问题主要特点：

- 手机号有11位，假如当作整数来处理范围太大了。我们不能使用桶排，或者计数排序。
- 假设我们要比较两个手机号码的a,b的大小，如果在前面几位中，a手机号码已将比b手机号大了，那么后面的几位就不用看了。

借助稳定排序算法，借助[11]节中举的订单金额时间排序例子，先按照最后一位来排序手机号，然后，再按照倒数地二位重新排序，以此类推，最后按照第一位重新排序。经过11次排序之后，手机号码就有序了。

![基数排序](D:\婕\数据结构与算法之美\picture\基数排序.jpg)

我们每次进行的排序必须是稳定的，这样才不会影响后续位数的排列。

根据每一位来进行排序，我们可以用到桶排或者计数排序，他们时间复杂度是O(n)。如果要排序的数据位数有k位，那么我们就需要K次桶排序或者计数排序，总时间复杂度就是O(k*n)。当K不大时，比如手机号码的例子，k最大就是11.所以基数排序的时间复杂度就近似与O(n)。

## **特殊例子**：对字典中20万单词进行排序

- 我们可以把所有单词补齐到相同长度，位数不够的可以在后面补"0"，
- 因为根据ASCII值，所有字母大于"0",所以补"0"不会影响到原有的大小顺序。这样就可以继续用基数排序了。

## 适用场景:cat2:

基数排序对排序数据又要求**，**

- **需要分隔出独立的"位"来进行比较，而且位之间有递进的关系**，
- *如果a数据的高位比b数据大，那剩下的低位就不用比较了*。
- 除此之外*，每一位的数据范围不能太大了*，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。



# 解答:key:

给根据年龄100万用户排序

类似给50万考生排序，先找到数据的范围,例如最小1岁最大120岁。我们可以遍历100万用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这个120个桶中的元素。这样就可以得到按照年龄排序100万用户的数据了。



# 内容小结

桶排序，计数排序，基数排序3种排序对要排序的数据都有比较严苛的要求，应用的不是非常广泛。但是如果数据符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。

**桶排序和计数排序的排序思想非常相似的，都是针对范围不大的数据，将数据划分为不同的桶来实现排序。**

基数排序要求数据可以划分成**高低位**，**位于位之间有递进关系**。比较两个数，我们只需要比较高位，高位相同的再比较低位。且**每一位得到数据范围不能太大**，因为基数排序算法**需要借助桶排序或者计数排序来完成每一位的排序工作。**



# 补充

**对大小写字母进行排序，要求大写在前，小写在后。大小写字母内部不要求有序。**

==双指针法（前后指针)==  

> 前指针从前向后找找到大写字母，后指针从后向前找找到小写字母。然后进行交换，直到两个指针相遇就停止，完成排序。

**进阶其中在添加数字，要求数字在中间。**

==分类，两次双指针（前后指针）==

> 先将数据非为小写字母和非小写字母进行排序，然后再对非小写字母进行数字和大写字母的双指针算法。