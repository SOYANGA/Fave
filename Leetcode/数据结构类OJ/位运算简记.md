# 位运算简记



## XOR-异或

> 异或：相同位0，不同为1.也可以用【不进位加法】来理解

异或操作的一些特点：

- **x ^  0 = x**
- **x ^ 1s = ~x   // 1s  = ~0**
- **x ^ (~x)= 1s**
- **x ^ x = 0**
- **a ^ b  = c   ->  a ^ c = b,  b ^ c = a   //交换ab**
- **a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c** 

## 实战常用的位运算操作

-  **x & 1 == 1 OR ==0 判断奇偶性  等价于 （ x%2 == 1）**
- **x = x & (x-1) => 清零最低为的1   （嵌套循环的化）一直到x = 0**
- **x & -x =>得到最低位的1**

## 更为复杂的位运算操作

| 操作                     | 运算                |
| ------------------------ | ------------------- |
| 将x最右边的n位清零       | x & (~0 << n)       |
| 获取x的第n位值（0或1)    | (x >> n) & 1        |
| 获取x的第n位的幂值       | x & (1 << (n - 1))  |
| 仅将第n位置为1           | x \| (1<<n)         |
| 仅将第n为置为0           | x & ( ~(1 << n))    |
| 将x最高位至第n位(含)清零 | x&( (1<<n)-1)       |
| 将第n位至第0位(含)清零   | x&(~((1<<(n+1))-1)) |



## 位运算练习

- **颠倒二进制位**

  颠倒给定的 32 位无符号整数的二进制位。

  

  示例 1：

  输入: 00000010100101000001111010011100
  输出: 00111001011110000010100101000000
  解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
        因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
  示例 2：

  输入：11111111111111111111111111111101
  输出：10111111111111111111111111111111
  解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
        因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。


  提示：

  请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
  在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/reverse-bits

  ```java
  public class Solution {
      // you need treat n as an unsigned value
      public int reverseBits(int n) {
          int result = 0;
          for(int i = 0; i < 32 ;i++){
              int temp = n >> i;
              //1.取出要反转的每一位二进制
              temp &= 1;
              //2.将该二进制位放到反转后的位置
              temp  <<= (31-i);
              //3.将该位添加到结果上
              result |= temp;
          }
          return result;
      }
  }
  ```

- #### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

- 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

   

  示例 1：

  输入：00000000000000000000000000001011
  输出：3
  解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
  示例 2：

  输入：00000000000000000000000010000000
  输出：1
  解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
  示例 3：

  输入：11111111111111111111111111111101
  输出：31
  解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/number-of-1-bits

  ```java
  public class Solution {
      // you need to treat n as an unsigned value
      public int hammingWeight(int n) {
          int count = 0;
          while(n!=0){
              n &=(n-1);
              count++;
          }
          return count;
      }
  }
  ```

- #### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

  给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

  示例 1:

  输入: 2
  输出: [0,1,1]
  示例 2:

  输入: 5
  输出: [0,1,1,2,1,2]

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/counting-bits

  ```java
  class Solution {
      public int[] countBits(int num) {
          int result[] = new int[num+1];
          for(int i = 0; i <= num; i++){
              result[i] = result[i>>1]+(i&1);
              //result[i] = result[i&(i-1)]+1;
          }
          return result;
      }
  }
  ```

  

> 
>
> 方法1：i & (i - 1)去掉i最右边的一个1；因i & (i - 1）< i，故result[i & (i - 1)]已计算，所以i中1的个数为
>
> result[i & (i - 1)] + 1
>
> 方法2：i >> 1去掉i的最低位；因(i >> 1) < i，故result[i >> 1]已计算，因此i中1的个数为i >> 1中1的个数加最后一位1的个数，即为result[i >> 1] + (i & 1)



- #### [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)

  给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

  示例 1:

  输入: 1
  输出: true
  解释: 20 = 1
  示例 2:

  输入: 16
  输出: true
  解释: 24 = 16
  示例 3:

  输入: 218
  输出: false

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/power-of-two

  ```java
  class Solution {
      public boolean isPowerOfTwo(int n) {
          return (n>0)&&(n&(n-1))==0;
      }
  }
  ```

  

> 1.**一个数是2的n次方 ，该数的比特位中则一定是且仅有一个1**
>
> 则判断是否是2的幂则转变位判断x中1的个数
>
> x!=0 x&(x-1)  = >count++  final count = 1;
>
> 2.mod
>
> 3.logx = int



### 用位运算实现加法



用位运算实现加法也就是计算机用二进制进行运算，32位的CPU只能表示32位内的数，这里先用1位数的加法来进行，在不考虑进位的基础上，如下

> 1. 1 + 1 = 0
> 2. 1 + 0 = 1
> 3. 0 + 1 = 1
> 4. 0 + 0 = 0


很明显这几个表达式可以用位运算的“^”来代替，如下

> 1. 1 ^ 1 = 0
> 2. 1 ^ 0 = 1
> 3. 0 ^ 1 = 1
> 4. 0 ^ 0 = 0

这样我们就完成了简单的一位数加法，那么要进行二位的加法，这个方法可行不可行呢？肯定是不行的，矛盾就在于，如何去
获取进位？要获取进位我们可以如下思考：

> 1. 0 + 0 = 0
> 2. 1 + 0 = 0
> 3. 0 + 1 = 0
> 4. 1 + 1 = 1
> 5. //换个角度看就是这样
> 6. 0 & 0 = 不进位
> 7. 1 & 0 = 不进位
> 8. 0 & 1 = 不进位
> 9. 1 & 1 = 进位

正好，在位运算中，我们用“<<”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式

> 1. //进位可以用如下表示：
> 2. (x&y)<<1

到这里，我们基本上拥有了这样两个表达式

> 1. x^y //执行加法
> 2. (x&y)<<1 //进位操作

我们来做个2位数的加法，在不考虑进位的情况下

> 1. 11+01 = 100  // 本来的算法
> 2.  
> 3. // 用推算的表达式计算
> 4. 11 ^ 01 = 10
> 5.  
> 6. (11 & 01) << 1 = 10
> 7.  
> 8. //到这里 我们用普通的加法去运算这两个数的时候就可以得到 10 + 10 = 100
> 9. //但是我们不需要加法，所以要想别的方法，如果让两个数再按刚才的算法计算一次呢
> 10.  
> 11. 10 ^ 10 = 00
> 12.  
> 13. (10 & 10) << 1 = 100

到这里基本上就得出结论了，其实后面的那个 “00” 已经不用再去计算了，因为第一个表达式就已经算出了结果。

继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果。

 

c代码如下：

```c
int Add(int a,int b)
{
 int jw=a&b;
 int jg=a^b;
 while(jw)
 {
  int t_a=jg;
  int t_b=jw<<1;
  jw=t_a&t_b;
  jg=t_a^t_b;
 }
 return jg;
}
```

 

计算机本质是二进制运算，许多高人和天书都展示了如何用位运算来实现让人纠结却又惊奇的事情。在豆瓣上看到一篇日志描述如何用位运算实现乘法，其实问题解决的关键是如何用位运算实现加法。觉得原文叙述不够精确，现总结如下。

**定理1：设a，b为两个二进制数，则a+b = a^b + (a&b)<<1。**
**证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&b)<<1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。**
**定理2：使用定理1可以实现只用位运算进行加法运算。**
**证明：利用定理1中的等式不停对自身进行迭代。每迭代一次，进位补偿右边就多一位0，因此最多需要加数二进制位长度次迭代，进位补偿就变为0，这时运算结束。**